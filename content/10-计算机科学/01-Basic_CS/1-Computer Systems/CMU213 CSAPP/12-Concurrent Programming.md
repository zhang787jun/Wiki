---
title: "12-Concurrent Programming(并发编程)"
layout: page
date: 2099-06-02 00:00
---

[TOC]

# 1. 基础


死锁（Deadlock）： 十字路口，4辆车都同时要通过，结果谁都过不去。

## 1.1. 并发与并行

`并发` ： 指在同一时刻，有多条指令在多个处理器上**同时**执行。所以无论从微观还是从宏观来看，二者都是一起执行的。那么它们就是**并发的**（concurrent）。这种常见的现象称为**并发**（concurrency）


`并行`：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并**不是同时**执行的，只是把时间分成若干段，使多个进程**快速交替**的执行。

## 1.2. 顺序程序与并发程序
 

![](https://gblobscdn.gitbook.com/assets%2F-MHt_spaxGgCbp2POnfq%2F-MIeGUyqqGlF_Z7cnC_d%2F-MIeGiRTyXMoSflvbajp%2F12-30%20%E9%A1%BA%E5%BA%8F%E3%80%81%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E9%9B%86%E5%90%88%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png?alt=media&token=776fc3af-f2c8-43fb-94ca-93168c54a6f3)



所有程序的集合能够被划分成不相交的顺序程序集合和并发程序的集合。
$$所有程序=顺序程序+并发程序$$

`顺序程序`只有一条逻辑流。
`并发程序`有多条并发流。
`并行程序`是一个运行在多个处理器上的并发程序。


。随着线程数量的增加，运行时间实际上增加了一点儿，这是由于在一个核上多个线程上下文切换的开销。由于这个原因，并行程序常常被写为每个核上只运行一个线程。

## 1.3. 常见场景

1. `I/O`。访问慢速 I/O 设备。当一个应用正在等待来自慢速I/O设备（如磁盘）的数据到达时，内核会运行其他进程，使CPU保持繁忙。
   1. 与人交互。和计算机交互的人要求计算机有同时执行多个任务的能力。如，我们在打印一个文档时，可能想要调整一个窗口的大小。
2. `通过推迟工作以降低延迟`。有时，应用程序能够通过推迟其他操作和并发地执行它们，利用并发来降低某些操作的延迟。例如，一个动态内存分配器可以通过推迟合并，把它放到一个运行在较低优先级上的并发“合并”流中，在有空闲的CPU周期时充分利用这些空闲周期，从而降低单个free操作的延迟。
3. 服务多个网络客户端。创建一个并发服务器，它为每个客户创建一个单独的逻辑流。允许服务器同时为多个客户端服务，也避免了慢速客户端独占服务器。
在多核机器上进行并行计算。多核处理器包含多个CPU，可以同时处理多个应用程序


I/O 多路复用。应用程序在一个进程地上下文中显式地调度它们自己地逻辑流。逻辑流被模型化为状态机，数据到达文件描述符后，主程序显式地从一个状态转换到另一个状态。因为程序是单独地进程，所有所有地流都共享同一个地址空间。
线程。线程是运行在一个单一进程上下文中地逻辑流，由内核进行调度。

## 1.4. 内核级并发与程序级并发

现代操作系统提供了3种基本的构造并发程序的方法：

1. 多进程、
2. I/O多路复用、
3. 多线程。

# 2. 基于进程的并发编程

每个逻辑控制流都是一个进程，由内核来调度和维护。因为**每个进程有独立的虚拟地址空间**，所以要想和其他进程通信，控制流必须使用某种显式的进程间通信机制（比较慢）。 如服务器端监听特定的端口，当有新的客户端连接时，创建新的端口号，并派生一个子进程，子进程使用这个新的端口号与客户端进行通信。这样，当有多个客户端连接时，它们将以多进程的方式并发地执行。 子进程与父进程共享文件表，但是不共享用户地址空间。

## 2.1. 优势与劣势
1. **特点**
对于在父、子进程间共享状态信息，进程有一个非常清晰的模型：共享文件表，但是不共享用户地址空间。**进程有独立的地址空间**既是优点也是缺点。

2. **优势**
**环境隔离**。这样一来，一个进程不可能不小心覆盖另一个进程的虚拟内存，这就消除了许多令人迷惑的错误一一这是一个明显的优点。

3. **劣势**
**高开销的进程间通信**。另一方面，独立的地址空间使得进程共享状态信息变得更加困难。为了共享信息，它们必须使用显式的 IPC（进程间通信）机制。基于进程的设计的另一个缺点是，它们往往比较慢，因为进程控制和IPC 的开销很高。

# 3. 基于I/O多路复用(事件)的并发编程


## 3.1. IO类型
同步阻塞IO（Blocking IO）：即传统IO模型
同步非阻塞IO（Non-Blocking IO）：默认常见的socket都是阻塞的，非阻塞IO要求socket被设置成NONBLOCK
IO多路复用（IO Multiplexing）：即经典的Reactor设计模式，也被称为异步阻塞IO，Java中的selector和linux中的epoll都是这种模型
异步IO（Asychronous IO）：即Proactor设计模式，也被称为异步非阻塞IO


应用程序在一个进程的上下文中显式地调度它们自己的逻辑流，逻辑流被模型化为状态机，数据达到文件描述符后，主程序显式地从一个状态机换到另一个状态机。因为程序是一个单独的进程，所以所有的流都共享同一个地址空间。 基本的思路是使用select函数，要求内核在发生读写操作时挂起进程，只有在一个或多个I/O事件发生后，才将控制返回给应用程序。

// 返回已准备好的描述符的个数

int select(int n, fd_set *fdset, NULL, NULL, NULL);

I/O多路复用可以作为并发事件驱动程序的基础。在事件驱动程序中，将逻辑流模型化为状态机，一个状态机就是一组状态、输入事件和转移。其中转移就是将状态和输入事件映射到新的状态。对于每个新的客户端，基于I/O多路复用的并发服务器会创建一个新的状态机，并将它和已连接的描述符联系起来。每个状态机都有一个状态：等待相应的描述符准备好可读；一个输入事件：描述符可读了；一个转移：从描述符读一个文本行。 服务器使用I/O多路复用，借助select函数检测输入事件的发生，当每个已连接描述符准备好可读时，服务器就为相应的状态机执行转移。

基于I/O多路复用的事件驱动服务器是运行在单一进程上下文中的，因此每个逻辑流都能访问该进程的全部地址空间，这使得在流之间共享数据非常容易。




## 3.2. I/O 多路复用技术的优劣
**优势**
1. **自定义功能增强**。事件驱动设计的一个优点是，它比基于进程的设计给了程序员更多的对程序行为的控制。例如，我们可以设想编写一个事件驱动的并发服务器，为某些客户端提供它们需要的服务，而这对于基于进程的并发服务器来说，是很困难的。
2. **共享数据容易**。另一个优点是，一个基于 I/O 多路复用的事件驱动服务器是运行在单一进程上下文中的，因此每个逻辑流都能访问该进程的全部地址空间。这使得在流之间共享数据变得很容易。
   1. 一个与作为单个进程运行相关的优点是，你可以利用熟悉的调试工具，例如 GDB，来调试你的并发服务器，就像对顺序程序那样。最后，事件驱动设计常常比基于进程的设计要高效得多，因为它们不需要进程上下文切换来调度新的流。
**劣势**
1. **编码复杂**。事件驱动设计一个明显的缺点就是编码复杂。我们的事件驱动的并发 echo 服务器需要的代码比基于进程的服务器多三倍，并且很不幸，随着并发粒度的减小，复杂性还会上升。这里的粒度是指每个逻辑流每个时间片执行的指令数量。例如，在示例并发服务器中，并发粒度就是读一个完整的文本行所需要的指令数量。只要某个逻辑流正忙于读一个文本行，其他逻辑流就不可能有进展。对我们的例子来说这没有问题，但是它使得在“故意只发送部分文本行然后就停止”的恶意客户端的攻击面前，我们的事件驱动服务器显得很脆弱。修改事件驱动服务器来处理部分文本行不是一个简单的任务，但是基于进程的设计却能处理得很好，而且是自动处理的。
   
2. **硬件利用低效**。基于事件的设计另一个重要的缺点是它们不能充分利用**多核处理器**。


## 3.3. 应用--Web服务器

现代高性能服务器（例如 Node.js、nginx 和 Tornado）使用的都是基于 I/O 多路复用的事件驱动的编程方式，主要是因为相比于进程和线程的方式，它有明显的性能优势





# 4. 基于线程的并发编程

线程是运行在进程上下文中的逻辑流，由内核自动调度，每个线程都有自己的线程上下文，包括唯一的线程ID、栈、程序计数器、通用目的寄存器和条件码等。所有运行在一个进程里的线程共享该进程的整个虚拟地址空间。

基于线程的逻辑流结合了基于进程和基于I/O多路复用的流的特性，同进程一样，线程由内核自动调度，并且内核会通过一个整数ID来识别线程。同基于I/O多路复用的流一样，多个线程运行在单一进程的上下文中，因此共享这个进程虚拟地址空间的整个内容：代码、数据、堆、共享库、打开的文件。

每个进程开始时都是单一线程，这个线程称为主线程，之后在某一时刻主线程创建一个对等线程（peer thread），然后两个线程就并发地运行。当主线程执行一个慢速系统调用时，因为它被系统的间隔计时器中断，控制就会通过切换上下文传递到对等线程，对等线程执行一段时间后再将控制传递回主线程。

线程不同于进程的方面在于线程的上下文要比进程小很多，线程的上下文切换也比进程的上下文切换开销小。此外不像进程那样严格地按照父子层次来组织，一个进程的所有线程组成一个对等线程池，独立于其他进程创建的线程。因为有对等线程池，一个线程可以杀死它的任何对等线程，或者等待它的任意对等线程终止。每个对等线程都能读写相同的共享数据。



Posix线程是在C程序中处理线程的一个标准接口，在大多数Unix系统上都可用，定义了大约60个函数（以Pthread_开头），可以执行创建、杀死、回收线程，与对等线程安全地共享数据，通知对等线程系统状态的变化等等。
多线程程序中的共享变量

信号量，P、V操作，同步、互斥等，略。

# 5. 使用线程提高并行性

![](https://gblobscdn.gitbook.com/assets%2F-MHt_spaxGgCbp2POnfq%2F-MIeGtG8SXEjS3imq1ql%2F-MIeH8pM3e8KVtMelOrl%2F12-35%20psum-local%E7%9A%84%E6%80%A7%E8%83%BD.png?alt=media&token=ef1e66fd-0b2c-46fe-a080-1a7add794c8c)

>为什么运行时间不随着核数的增加线性下降？
随着线程数量的增加，运行时间实际上增加了一点儿，这是由于在一个核上多个线程上下文切换的开销。由于这个原因，并行程序常常被写为每个核上只运行一个线程。

## 5.1. 并行程序的性能指标
1. 绝对时间
   1. 
2. 加速比（speedup）
   1.  `绝对加速比(absolute speedup)`
   2.  `想对加速比(relative speedup)`
3. 效率（efficiency）

|                     |       |       |       |       |       |
| :------------------ | :---: | :---: | :---: | :---: | :---: |
| 线程（t）           |   1   |   2   |   4   |   8   |  16   |
| 核（p）             |   1   |   2   |   4   |   4   |   4   |
| 运行时间（$$T_p$$） | 1.06  | 0.54  | 0.28  | 0.29  | 0.30  |
| 加速比（$$S_p$$）   |   1   |  1.9  |  3.8  |  3.7  |  3.5  |
| 效率（$$E_p$$）     | 100%  |  98%  |  95%  |  91%  |  88%  |


# 6. 线程安全

## 概述
![](https://gblobscdn.gitbook.com/assets%2F-MHt_spaxGgCbp2POnfq%2F-MIeI8u0jJUPqBGvnFII%2F-MIeIQR_paozIme5AMJr%2F12-39%20%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%87%BD%E6%95%B0%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E9%9B%86%E5%90%88%E5%85%B3%E7%B3%BB.png?alt=media&token=998c503f-45d6-45ea-b168-bc460b65ee9e)
$$ 所有函数=线程安全函数+线程不安全函数$$

`线程安全的(thread-safe)函数`：当函数被<**多个**><**并发线程**>反复地调用时，它会一直产生正确的结果。
`线程不安全的(thread-unsafe)函数`：不是线程安全的的函数都是线程不安全的(thread-unsafe)函数
## 线程不安全

我们能够定义出四个（不相交的）线程不安全函数类：
1. **不保护共享变量的函数**。函数对一个未受保护的全局计数器变量加 1。将这类线程不安全函数变成线程安全的，相对而言比较容易：利用像 P 和 V 操作这样的同步操作来保护共享的变量。这个方法的优点是在调用程序中不需要做任何修改。缺点是同步操作将减慢程序的执行时间。
2. **保持跨越多个调用的状态的函数**。一个伪随机数生成器是这类线程不安全函数的简单例子。请参考图 12-37 中的伪随机数生成器程序包。rand 函数是线程不安全的，因为当前调用的结果依赖于前次调用的中间结果。当调用 srand 为 rand 设置了一个种子后，我们从一个单线程中反复地调用 rand，能够预期得到一个可重复的随机数字序列。然而，如果多线程调用 rand 函数，这种假设就不再成立了。
3. **返回指向静态变量的指针的函数**

## 线程安全

### 