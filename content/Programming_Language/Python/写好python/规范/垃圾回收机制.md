---
title: "Python 垃圾回收机制"
layout: page
date: 2099-06-02 00:00
---
[TOC]
# 1. python 垃圾回收机制

参考 https://zhuanlan.zhihu.com/p/62282961
https://docs.python.org/zh-cn/3.8/library/gc.html

垃圾回收机制指的是内存管理机制
* C++/C 中用户自主为变量申请固定长度内存（或申请动态内存）,delete 变量销毁占用内存，该设计为大量内存泄露，悬空指针等bug埋下隐患
* 高级语言如java,c#等，都采用了垃圾收集机制

## 1.1. 一切皆对象
python里每一个东西都是对象，它们的核心就是一个结构体：PyObject
```python

a="sting_1"
b="sting_1"
print ("a id is {}\nb id is {}\n'sting_1' id is {}".format(id(a),id(b),id("sting_1")))

>>>
a id is 1546431601832
b id is 1546431601832
'sting_1' id is 1546431601832

a is b 
>>> True
a is "string_1"
>>> True
a==b
>>> True

import sys
sys.getrefcount(a)
>>> 3

```

python采用的是引用**计数机制**为主，**标记-清除**和**分代收集**（隔代回收）两种机制为辅的策略。

### 1.1.1. 1 计数机制

#### 1.1.1.1. 1 计数机制核心
一旦对象的引用计数为0，该对象立即被回收，对象占用的内存空间将被释放


| 优点                                                                                                                         | 缺点                 |
| :--------------------------------------------------------------------------------------------------------------------------- | :------------------- |
| 简单                                                                                                                         | 维护引用计数消耗资源 |
| 实时性：一旦没有引用，内存就直接释放了，不用像其他机制得等到特定时机。实时性还带来一个好处：处理回收内存的时间分摊到了平时。 | 循环引用             |

#### 1.1.1.2. 2 导致引用计数+1的情况
1. 对象被创建，例如a=23
2. 对象被引用，例如b=a
3. 对象被作为参数，传入到一个函数中，例如func(a)
4. 对象作为一个元素，存储在容器中，例如list1=[a,a]
#### 1.1.1.3. 3 导致引用计数-1的情况
1. 对象的别名被显式销毁，例如`del a`
2. 对象的别名被赋予新的对象，例如 `a=24`
3. 一个对象离开它的作用域，例如f函数执行完毕时，func函数中的局部变量（全局变量不会）
4. 对象所在的容器被销毁，或从容器中删除对象


**循环引用导致内存泄露**
```python
def f2():
    '''循环引用'''
    while True:
        c1=A() # 创建id: 0001 counts:1
        c2=A() #  创建id: 0002 counts:1
        c1.t=c2 # id: 0002 counts:2
        c2.t=c1 # id: 0001 counts:2
        del c1 # id: 0001 counts:1
        del c2 # id: 0002 counts:1
```
创建了c1，c2后，这两个对象的引用计数都是1，执行c1.t=c2和c2.t=c1后，引用计数变成2.
在del c1后，内存c1的对象的引用计数变为1，由于不是为0，所以c1的对象不会被销毁,同理，在del c2后也是一样的。
虽然它们两个的对象都是可以被销毁的，但是由于循环引用，导致垃圾回收器都不会回收它们，所以就会导致内存泄露。

### 1.1.2. 分代回收
分代回收是一种以空间换时间的操作方式，Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python将内存分为了3“代”，分别为：
1. 年轻代（第0代）
2. 中年代（第1代）
3. 老年代（第2代）

他们对应的是3个链表，它们的垃圾收集频率随着对象存活时间的增大而减小。

新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。
同时，分代回收是建立在标记清除技术基础之上。分代回收同样作为Python的辅助垃圾收集技术处理那些容器对象
### 1.1.3. 标记清除

标记清除（Mark—Sweep）』算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。它分为两个阶段：第一阶段是标记阶段，GC会把所有的『活动对象』打上标记，第二阶段是把那些没有标记的对象『非活动对象』进行回收。那么GC又是如何判断哪些是活动对象哪些是非活动对象的呢？


<img src=https://pic1.zhimg.com/80/v2-543bb871b0eb79e4b6b9186ac1588e34_hd.jpg>

对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。 mark-sweepg 在上图中，我们把小黑圈视为全局变量，也就是把它作为root object，从小黑圈出发，对象1可直达，那么它将被标记，对象2、3可间接到达也会被标记，而4和5不可达，那么1、2、3就是活动对象，4和5是非活动对象会被GC回收。

标记清除算法作为Python的辅助垃圾收集技术主要处理的是一些容器对象，比如list、dict、tuple，instance等，因为对于字符串、数值对象是不可能造成循环引用问题。Python使用一个双向链表将这些容器对象组织起来。不过，这种简单粗暴的标记清除算法也有明显的缺点：清除非活动的对象前它必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象

## 1.2. 使用gc模块进行垃圾回收

gc模块的一个主要功能就是解决循环引用的问题。
使用gc模块的垃圾回收机制的主要作用就是发现并处理不可达的垃圾对象。
```
gc模块的垃圾回收机制=垃圾检测+垃圾回收
```
### 1.2.1. 垃圾检测
#### 1.2.1.1. 1 gc模块监控的范围
```python
is_tracked=gc.is_tracked(obj)
>>>type(is_tracked)
bool
#当对象正在被垃圾回收器监控时返回 True ，否则返回 False 。
```
一般来说，原子类的实例不会被监控，而**非原子类（如容器、用户自定义的对象）会被监控**。然而，会有一些特定类型的优化以便减少垃圾回收器在简单实例（如只含有原子性的键和值的字典）上的消耗。

#### 1.2.1.2. 2 垃圾检测
垃圾检测就是检测不可达对象(unreachable object)，参考 3.标记清除


注意：
如果循环引用中，两个对象都定义了__del__方法，gc模块不会销毁这些不可达对象，因为gc模块不知道应该先调用哪个对象的__del__方法，所以为了安全起见，gc模块会把对象放到gc.garbage中，但是不会销毁对象。


### 1.2.2. 垃圾回收

有三种情况会触发垃圾回收：

1. 调用gc.collect()
2. 当gc模块的计数器达到阈值的时候。
3. 程序退出的时候。


```python
import gc
if gc.is_enable()==False:
    gc.enable()

num_of_unreachable_objects=gc.collect(generation=2)
# generation=0 检查第1代的对象
# generation=1 检查1、2代的对象
# generation=2 检查1、2、3代的对象
# 返回unreachable objects 对象的数量

type(num_of_unreachable_objects) 
>>> int 

# 当前自动执行垃圾回收的计数器  current collection counts 
counts_tuple=gc.get_count()
type(counts_tuple)
>>>
tuple 
1_nums,2_nums,3_nums=gc.get_count()
# 1_nums 1代的垃圾对象的数目
# 2_nums 2代的垃圾对象的数目
# 3_nums 3代的垃圾对象的数目

#自动回收阈值
gc.set_threshold(threshold0[, threshold1[, threshold2])
```
