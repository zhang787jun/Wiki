---
title: "视频编解码"
layout: page
date: 2099-06-02 00:00
---
[TOC]


# 解码技术

关于视频软解码的资料网上比较多了，但是关于硬解可供参考的资料非常有限，虽然总得来说软解和硬解的基本逻辑一样，但是实现细节上的差别还是比较多的。

## 软解与硬解的区别

软解和硬解的流程
红色箭头表示需要在系统内存与显存之间进行IO，比较费时。


解码方案

- OpenCV

OpenCV封装好了cv::gpu::VideoReader_GPU类可直接进行采用GPU进行硬解，其底层实现是借助于视频解码库CUVID，CUVID是基于CUDA的视频解码库，故而只支持NVIDIA的显卡。

- Intel QSV

可以下载相应的SDK进行开发，FFmpeg的demo里有实现，现在忘光了。

- FFmpeg

FFmpeg是一套包含视音频编解码、采集、转码及处理等功能的开源库，源码由C语言编写。实现了多种标准的硬解码技术，包括Intel QSV，CUDA。

# 关键帧提取

```python 
# https://stackoverflow.com/questions/42798634/extracting-keyframes-python-opencv
import os
import cv2
import subprocess

filename = '/home/andriy/Downloads/video.mp4'

def get_frame_types(video_fn):
    command = 'ffprobe -v error -show_entries frame=pict_type -of default=noprint_wrappers=1'.split()
    out = subprocess.check_output(command + [video_fn]).decode()
    frame_types = out.replace('pict_type=','').split()
    return zip(range(len(frame_types)), frame_types)

def save_i_keyframes(video_fn):
    frame_types = get_frame_types(video_fn)
    i_frames = [x[0] for x in frame_types if x[1]=='I']
    if i_frames:
        basename = os.path.splitext(os.path.basename(video_fn))[0]
        cap = cv2.VideoCapture(video_fn)
        for frame_no in i_frames:
            cap.set(cv2.CAP_PROP_POS_FRAMES, frame_no)
            ret, frame = cap.read()
            outname = basename+'_i_frame_'+str(frame_no)+'.jpg'
            cv2.imwrite(outname, frame)
            print ('Saved: '+outname)
        cap.release()
    else:
        print ('No I-frames in '+video_fn)

if __name__ == '__main__':
    save_i_keyframes(filename)
```

视频分析应用
![](../../attach/images/2020-12-08-22-13-09.png)