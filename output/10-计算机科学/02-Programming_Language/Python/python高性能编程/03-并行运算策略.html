<!DOCTYPE HTML>
<html>

<head>
    <link rel="Stylesheet" type="text/css" href="/Wiki/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/Wiki/static/css/tango.css">
    <link rel="shortcut icon" href="/Wiki/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/Wiki/favicon.ico" type="image/x-icon">
    <title>03-并行运算策略 - Jun's personal knowledge wiki</title>
    <meta name="keywords" content="Technology, MachineLearning, DataMining, Wiki" />
    <meta name="description" content="A wiki website" />
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
            }
        });
    </script>
    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
        </script>
</head>

<body>

    <div id="container">
        
<div id="header">
  <div id="post-nav"><a href="/Wiki/">Home</a>&nbsp;»&nbsp;<a href="/Wiki/#10-计算机科学">10-计算机科学</a>&nbsp;»&nbsp;<a href="/Wiki/#-02-Programming_Language">02-Programming_Language</a>&nbsp;»&nbsp;<a href="/Wiki/#-Python">Python</a>&nbsp;»&nbsp;<a href="/Wiki/#-python高性能编程">python高性能编程</a>&nbsp;»&nbsp;03-并行运算策略</div>
</div>
<div class="clearfix"></div>
<div id="title">03-并行运算策略</div>
<div id="content">
  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#_1">多任务编程</a><ul>
<li><a href="#1">1. 任务在计算机上的完成（进程、线程）</a><ul>
<li><a href="#11">1.1 进程</a><ul>
<li><a href="#111-multiprocessing">1.1.1 多进程(multiprocessing)</a></li>
<li><a href="#112">1.1.2 进程管理</a><ul>
<li><a href="#1121">1.1.2.1  进程锁</a></li>
<li><a href="#1122-ipc">1.1.2.2 进程间通信（IPC）</a></li>
</ul>
</li>
<li><a href="#113-daemon">1.1.3 守护进程(daemon)</a></li>
</ul>
</li>
<li><a href="#12">1.2 线程</a><ul>
<li><a href="#121-multi_thread">1.2.1 多线程（multi_Thread）</a></li>
<li><a href="#122">1.2.2  线程管理</a><ul>
<li><a href="#122-threadlocal">1.2.2  线程锁 ThreadLocal</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-python-">2. Python概念：可迭代、迭代器、生成器--&gt;协程</a><ul>
<li><a href="#11_1">1.1 可迭代</a></li>
<li><a href="#12_1">1.2 迭代器</a></li>
<li><a href="#13">1.3 生成器</a><ul>
<li><a href="#131">1.3.1 如何创建一个生成器</a><ul>
<li><a href="#1_1">1. 使用列表生成式</a></li>
<li><a href="#2-yield">2. 实现了yield的函数(生成器函数)</a></li>
</ul>
</li>
<li><a href="#132">1.3.2 如何运行/激活生成器</a></li>
<li><a href="#133">1.3.3 生成器的执行状态</a></li>
<li><a href="#134">1.3.4  生成器的异常处理</a></li>
<li><a href="#135-yield">1.3.5 从生成器过渡到协程：yield</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-io-">3. 异步IO框架--协程</a><ul>
<li><a href="#yield">yield</a></li>
<li><a href="#gevent-">gevent --第三方库</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_2">示例</a><ul>
<li><a href="#for">将for 循环使用多线程处理</a></li>
</ul>
</li>
<li><a href="#_3">进程池</a></li>
<li><a href="#_4">线程池的基本使用</a><ul>
<li><a href="#submit">submit</a></li>
<li><a href="#wait">wait</a></li>
<li><a href="#as_completed">as_completed</a></li>
<li><a href="#map">map</a></li>
</ul>
</li>
</ul>
</div>
<h1 id="_1">多任务编程</h1>
<p>东西不够，时间有限，互相依赖，需要协调</p>
<div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#_1">多任务编程</a><ul>
<li><a href="#1">1. 任务在计算机上的完成（进程、线程）</a><ul>
<li><a href="#11">1.1 进程</a><ul>
<li><a href="#111-multiprocessing">1.1.1 多进程(multiprocessing)</a></li>
<li><a href="#112">1.1.2 进程管理</a><ul>
<li><a href="#1121">1.1.2.1  进程锁</a></li>
<li><a href="#1122-ipc">1.1.2.2 进程间通信（IPC）</a></li>
</ul>
</li>
<li><a href="#113-daemon">1.1.3 守护进程(daemon)</a></li>
</ul>
</li>
<li><a href="#12">1.2 线程</a><ul>
<li><a href="#121-multi_thread">1.2.1 多线程（multi_Thread）</a></li>
<li><a href="#122">1.2.2  线程管理</a><ul>
<li><a href="#122-threadlocal">1.2.2  线程锁 ThreadLocal</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-python-">2. Python概念：可迭代、迭代器、生成器--&gt;协程</a><ul>
<li><a href="#11_1">1.1 可迭代</a></li>
<li><a href="#12_1">1.2 迭代器</a></li>
<li><a href="#13">1.3 生成器</a><ul>
<li><a href="#131">1.3.1 如何创建一个生成器</a><ul>
<li><a href="#1_1">1. 使用列表生成式</a></li>
<li><a href="#2-yield">2. 实现了yield的函数(生成器函数)</a></li>
</ul>
</li>
<li><a href="#132">1.3.2 如何运行/激活生成器</a></li>
<li><a href="#133">1.3.3 生成器的执行状态</a></li>
<li><a href="#134">1.3.4  生成器的异常处理</a></li>
<li><a href="#135-yield">1.3.5 从生成器过渡到协程：yield</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-io-">3. 异步IO框架--协程</a><ul>
<li><a href="#yield">yield</a></li>
<li><a href="#gevent-">gevent --第三方库</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_2">示例</a><ul>
<li><a href="#for">将for 循环使用多线程处理</a></li>
</ul>
</li>
<li><a href="#_3">进程池</a></li>
<li><a href="#_4">线程池的基本使用</a><ul>
<li><a href="#submit">submit</a></li>
<li><a href="#wait">wait</a></li>
<li><a href="#as_completed">as_completed</a></li>
<li><a href="#map">map</a></li>
</ul>
</li>
</ul>
</div>
<p><strong>问题：</strong> 有多任务怎么办？</p>
<h2 id="1">1. 任务在计算机上的完成（进程、线程）</h2>
<p><strong>进程Process</strong> 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。操作系统将物理CPU 虚拟称为多个CPU，每个虚拟CPU运行一个进程</p>
<p><strong>线程thread</strong> 是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位</p>
<p>进程=[线程1+线程2+...+线程n]</p>
<table>
<thead>
<tr>
<th align="right">项目</th>
<th align="right">进程</th>
<th align="right">线程</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">地址空间</td>
<td align="right">进程之间相互独立</td>
<td align="right">同一进程下个线程共享，无法分配资源</td>
</tr>
<tr>
<td align="right">通信</td>
<td align="right">进程间通信IPC</td>
<td align="right">线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。</td>
</tr>
<tr>
<td align="right">调度和切换</td>
<td align="right">慢</td>
<td align="right">快</td>
</tr>
<tr>
<td align="right">多线程系统中</td>
<td align="right">是可执行实体</td>
<td align="right">线程不是一个可执行的实体</td>
</tr>
</tbody>
</table>
<h3 id="11">1.1 进程</h3>
<h4 id="111-multiprocessing">1.1.1 多进程(multiprocessing)</h4>
<p>参考 https://www.liaoxuefeng.com/wiki/1016959663602400/1017628290184064</p>
<p>父进程：当前进程（python解释器）<br />
子进程：将父进程复制一份</p>
<p>如果用多进程实现Master-Worker，主进程就是Master，其他进程就是Worker。</p>
<div class="hlcode"><pre><span class="n">graph</span> <span class="n">TB</span>
   <span class="n">A</span><span class="p">[</span><span class="err">主进程</span><span class="n">Master</span><span class="p">]</span>
   <span class="n">B</span><span class="p">[</span><span class="err">其他进程</span><span class="mi">1</span><span class="n">Worker1</span><span class="p">]</span>
   <span class="n">C</span><span class="p">[</span><span class="err">其他进程</span><span class="mi">2</span><span class="n">Worker2</span><span class="p">]</span>
   <span class="n">A</span><span class="o">--&gt;</span><span class="n">B</span>
   <span class="n">A</span><span class="o">--&gt;</span><span class="n">C</span>
</pre></div>


<p>进程创建需要占用系统内存来存放PCB的数据结构，所以，一个系统能够创建的进程总数是有限的，进程的最大数目取决于系统内存的大小，由系统安装时已经确定(若后期内存增加了，系统能够创建的进程总数也应增加，但是一般需要重新启动)。而用户数目、外设数量和文件等均与此无关。</p>
<div class="hlcode"><pre><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="c"># 子进程要执行的代码</span>
<span class="k">def</span> <span class="nf">run_proc</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Run child process </span><span class="si">%s</span><span class="s"> (</span><span class="si">%s</span><span class="s">)...&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()))</span>

<span class="k">if</span> <span class="n">__name__</span><span class="o">==</span><span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Parent process </span><span class="si">%s</span><span class="s">.&#39;</span> <span class="o">%</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">())</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">run_proc</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;test&#39;</span><span class="p">,))</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Child process will start.&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Child process end.&#39;</span><span class="p">)</span>


<span class="o">&gt;&gt;&gt;</span>
<span class="n">Parent</span> <span class="n">process</span> <span class="mf">928.</span>
<span class="n">Process</span> <span class="n">will</span> <span class="n">start</span><span class="o">.</span>
<span class="n">Run</span> <span class="n">child</span> <span class="n">process</span> <span class="n">test</span> <span class="p">(</span><span class="mi">929</span><span class="p">)</span><span class="o">...</span>
<span class="n">Process</span> <span class="n">end</span><span class="o">.</span>
</pre></div>


<h4 id="112">1.1.2 进程管理</h4>
<p>进程管理指的是操作系统调整多个进程的功能</p>
<h5 id="1121">1.1.2.1  进程锁</h5>
<p><strong>进程锁</strong>:也是为了控制同一操作系统中多个进程访问一个共享资源，只是因为程序的独立性，各个进程是无法控制其他进程对资源的访问的，但是可以使用本地系统的信号量控制（操作系统基本知识）。</p>
<h5 id="1122-ipc">1.1.2.2 进程间通信（IPC）</h5>
<p>IPC方法包括管道（PIPE）、消息排队、旗语、共用内存以及套接字（Socket）</p>
<h4 id="113-daemon">1.1.3 守护进程(daemon)</h4>
<p>守护进程(daemon)是一类在后台运行的特殊进程，用于执行特定的系统任务。</p>
<h3 id="12">1.2 线程</h3>
<p><strong>线程thread</strong> 是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。</p>
<h4 id="121-multi_thread">1.2.1 多线程（multi_Thread）</h4>
<p>一个进程可以开启多个线程，<strong>开启线程的数量受可用内存限制</strong>。<br />
如果是32位的机器，那么默认一个进程有2G的可用内存，而每个线程默认分析1M的栈空间，所以这种情况下理论最线程数在2000多个。一个解决办法是创建线程时减少线程栈的大小或是使用64位的系统。64位系统应该可以忽略这个问题了。<br />
当然受cpu及磁盘速度及物理内存的限制。不用到达上限值，你的机器应该已经是慢如牛车了。</p>
<p>32位系统一个进程用户空间为2G，一个线程默认需要1M堆栈(最少128K)，可以算一算极限。</p>
<p>如果用多线程实现Master-Worker，主线程就是Master，其他线程就是Worker。</p>
<div class="hlcode"><pre><span class="kn">import</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">threading</span>

<span class="c"># 新线程执行的代码:</span>

<span class="k">def</span> <span class="nf">loop</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;thread </span><span class="si">%s</span><span class="s"> is running...&#39;</span> <span class="o">%</span> <span class="n">threading</span><span class="o">.</span><span class="n">current_thread</span><span class="p">()</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;thread </span><span class="si">%s</span><span class="s"> &gt;&gt;&gt; </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">current_thread</span><span class="p">()</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;thread </span><span class="si">%s</span><span class="s"> ended.&#39;</span> <span class="o">%</span> <span class="n">threading</span><span class="o">.</span><span class="n">current_thread</span><span class="p">()</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">&#39;thread </span><span class="si">%s</span><span class="s"> is running...&#39;</span> <span class="o">%</span> <span class="n">threading</span><span class="o">.</span><span class="n">current_thread</span><span class="p">()</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">loop</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;LoopThread&#39;</span><span class="p">)</span>
<span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">t</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;thread </span><span class="si">%s</span><span class="s"> ended.&#39;</span> <span class="o">%</span> <span class="n">threading</span><span class="o">.</span><span class="n">current_thread</span><span class="p">()</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

<span class="err">执行结果如下：</span>

<span class="n">thread</span> <span class="n">MainThread</span> <span class="ow">is</span> <span class="n">running</span><span class="o">...</span>
<span class="n">thread</span> <span class="n">LoopThread</span> <span class="ow">is</span> <span class="n">running</span><span class="o">...</span>
<span class="n">thread</span> <span class="n">LoopThread</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span>
<span class="n">thread</span> <span class="n">LoopThread</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">2</span>
<span class="n">thread</span> <span class="n">LoopThread</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">3</span>
<span class="n">thread</span> <span class="n">LoopThread</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">4</span>
<span class="n">thread</span> <span class="n">LoopThread</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">5</span>
<span class="n">thread</span> <span class="n">LoopThread</span> <span class="n">ended</span><span class="o">.</span>
<span class="n">thread</span> <span class="n">MainThread</span> <span class="n">ended</span><span class="o">.</span>
</pre></div>


<h4 id="122">1.2.2  线程管理</h4>
<h5 id="122-threadlocal">1.2.2  线程锁 ThreadLocal</h5>
<p>二者的区别还是很明显的：请求发出后，是否需要等待请求结果，才能继续执行其他操作。</p>
<p>进程（Process）、线程（Thread）、协程（）</p>
<p>总结一下就是，多任务的实现有3种方式：<br />
1. 多进程模式；<br />
2. 多线程模式；<br />
3. 多进程+多线程模式。<br />
4. 单进程单线程的异步编程模型</p>
<table>
<thead>
<tr>
<th align="right">模式</th>
<th align="right">优点</th>
<th align="right">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">多进程</td>
<td align="right"><strong>稳定性高</strong>，因为一个子进程崩溃了，不会影响主进程和其他子进程。（当然主进程挂了所有进程就全挂了</td>
<td align="right"><strong>创建进程的代价大</strong></td>
</tr>
<tr>
<td align="right">多线程</td>
<td align="right">快一点，但是也快不到哪去</td>
<td align="right">任何一个线程挂掉都可能直接造成整个进程崩溃</td>
</tr>
<tr>
<td align="right">多进程+多线程的混合模式</td>
<td align="right">理论上解决 稳定性和效率问题</td>
<td align="right"></td>
</tr>
<tr>
<td align="right">协程</td>
<td align="right">单线程的异步编程模型，解决系统总的进程数量十分有限</td>
<td align="right"></td>
</tr>
</tbody>
</table>
<p><strong>对应到Python语言，单线程的异步编程模型称为<code>协程</code>，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。我们会在后面讨论如何编写协程。</strong></p>
<h2 id="2-python-">2. Python概念：可迭代、迭代器、生成器--&gt;协程</h2>
<table>
<thead>
<tr>
<th align="right">名称</th>
<th align="right">例子</th>
<th align="right">特征内置函数</th>
<th align="right">适用</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">可迭代对象</td>
<td align="right">字符串，list，dict，tuple，deque等都是<strong>可迭代的</strong></td>
<td align="right"><code>__iter__</code></td>
<td align="right">for</td>
</tr>
<tr>
<td align="right">迭代器</td>
<td align="right">特定的数据结构</td>
<td align="right"><code>__iter__</code> <code>__next__</code></td>
<td align="right">for next()</td>
</tr>
<tr>
<td align="right">生成器(generator)</td>
<td align="right">生成器是种特殊的迭代器，这种一边循环一边计算的机制，称为生成器：generator。</td>
<td align="right"><code>__iter__</code> <code>__next__</code> <code>close</code>,<code>gi_yieldfrom</code>,<code>send</code>,<code>throw</code></td>
<td align="right"><code>yield</code></td>
</tr>
<tr>
<td align="right"></td>
<td align="right"></td>
<td align="right"></td>
<td align="right"></td>
</tr>
</tbody>
</table>
<h3 id="11_1">1.1 可迭代</h3>
<p><strong>关键：</strong> <code>__iter__</code></p>
<p>字符串、列表、字典等 是 <strong>可迭代对象</strong> 但不是迭代器，也不是生成器。</p>
<blockquote>
<p><strong>扩展知识</strong>:<br />
可迭代对象，是其内部实现了，<code>__iter__</code> 这个方法，这个方法可使用for来循环。</p>
</blockquote>
<h3 id="12_1">1.2 迭代器</h3>
<p><strong>关键：</strong> <code>__iter__</code>+<code>__next__</code></p>
<p>所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。我们不能提前知道序列的长度</p>
<p><code>__init__</code> 函数内包括：</p>
<div class="hlcode"><pre><span class="err">`</span><span class="n">__iter__</span><span class="err">`</span><span class="o">:</span><span class="err">可以直接使用</span><span class="n">for</span><span class="err">来实现循环</span>
<span class="err">`</span><span class="n">__next__</span><span class="err">`</span><span class="o">:</span><span class="err">可以直接使用</span><span class="n">next</span><span class="p">()</span><span class="err">方法来实现</span>
</pre></div>


<p><strong>示例</strong></p>
<div class="hlcode"><pre><span class="n">class</span> <span class="n">Fib</span><span class="o">:</span>
    <span class="n">def</span> <span class="n">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="o">:</span>
        <span class="n">self</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">self</span><span class="p">.</span><span class="n">curr</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">def</span> <span class="n">__iter__</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="o">:</span>
        <span class="k">return</span> <span class="n">self</span>

    <span class="n">def</span> <span class="n">__next__</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="o">:</span>
        <span class="n">self</span><span class="p">.</span><span class="n">curr</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">prev</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">curr</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">curr</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">curr</span>

<span class="n">fib</span> <span class="o">=</span> <span class="n">Fib</span><span class="p">()</span>
<span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="n">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">:</span>
    <span class="n">print</span><span class="p">(</span><span class="n">next</span><span class="p">(</span><span class="n">fib</span><span class="p">))</span>
</pre></div>


<p>输出：</p>
<div class="hlcode"><pre><span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
<span class="mi">5</span>
<span class="mi">8</span>
<span class="mi">13</span>
<span class="mi">21</span>
<span class="mi">34</span>
<span class="mi">55</span>
</pre></div>


<h3 id="13">1.3 生成器</h3>
<p><strong>关键：</strong> yield</p>
<p>生成器，是在迭代器的基础上（可以用for循环，可以使用next()），再实现了yield。</p>
<p>yield 是什么东西呢，它相当于我们函数里的return。在每次next()，或者for遍历的时候，都会yield这里将新的值返回回去，并在这里阻塞，等待下一次的调用。正是由于这个机制，才使用生成器在Python编程中大放异彩。实现节省内存，实现异步编程。<br />
这种一边循环一边计算的机制，称为生成器：generator。</p>
<p>但是不需要像迭代器一样实现__iter__和__next__方法，只需要使用关键字yield就可以。</p>
<div class="hlcode"><pre><span class="k">def</span> <span class="nf">fib</span><span class="p">():</span>
    <span class="n">prev</span><span class="p">,</span> <span class="n">curr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">curr</span>
        <span class="n">curr</span><span class="p">,</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span> <span class="o">+</span> <span class="n">curr</span><span class="p">,</span> <span class="n">curr</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">fib</span><span class="p">()</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>

<span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
<span class="mi">5</span>
<span class="mi">8</span>
<span class="mi">13</span>
<span class="mi">21</span>
<span class="mi">34</span>
<span class="mi">55</span>
</pre></div>


<h4 id="131">1.3.1 如何创建一个生成器</h4>
<p>主要有如下两种方法</p>
<h5 id="1_1">1. 使用列表生成式</h5>
<div class="hlcode"><pre>    <span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="n">in</span> <span class="n">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
    <span class="n">print</span><span class="p">(</span><span class="n">isinstance</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">Generator</span><span class="p">))</span>  <span class="err">#</span> <span class="n">True</span>
</pre></div>


<blockquote>
<p>使用列表生成式，注意不是[]，而是()</p>
</blockquote>
<h5 id="2-yield">2. 实现了yield的函数(生成器函数)</h5>
<div class="hlcode"><pre>    <span class="n">def</span> <span class="n">mygen</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">:</span>
        <span class="n">now</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">now</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">:</span>
            <span class="n">yield</span> <span class="n">now</span>
            <span class="n">now</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="err">&#39;</span><span class="n">__main__</span><span class="err">&#39;</span><span class="o">:</span>
        <span class="n">gen</span> <span class="o">=</span> <span class="n">mygen</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">print</span><span class="p">(</span><span class="n">isinstance</span><span class="p">(</span><span class="n">gen</span><span class="p">,</span> <span class="n">Generator</span><span class="p">))</span>  <span class="err">#</span> <span class="n">True</span>
</pre></div>


<h4 id="132">1.3.2 如何运行/激活生成器</h4>
<p>由于生成器并不是一次生成所有元素，而是一次一次的执行返回，那么如何刺激生成器执行(或者说激活)呢？<br />
激活主要有两个方法:<br />
1. 使用next()<br />
2. 使用generator.send(None)</p>
<p>示例：</p>
<div class="hlcode"><pre>    <span class="n">def</span> <span class="n">mygen</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">:</span>
        <span class="n">now</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">now</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">:</span>
            <span class="n">yield</span> <span class="n">now</span>
            <span class="n">now</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="err">&#39;</span><span class="n">__main__</span><span class="err">&#39;</span><span class="o">:</span>
        <span class="n">gen</span> <span class="o">=</span> <span class="n">mygen</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

        <span class="err">#</span> <span class="err">通过交替执行，来说明这两种方法是等价的。</span>
        <span class="n">print</span><span class="p">(</span><span class="n">gen</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">None</span><span class="p">))</span>
        <span class="n">print</span><span class="p">(</span><span class="n">next</span><span class="p">(</span><span class="n">gen</span><span class="p">))</span>
        <span class="n">print</span><span class="p">(</span><span class="n">gen</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">None</span><span class="p">))</span>
        <span class="n">print</span><span class="p">(</span><span class="n">next</span><span class="p">(</span><span class="n">gen</span><span class="p">))</span>
</pre></div>


<p>输出</p>
<div class="hlcode"><pre>    <span class="mi">0</span>
    <span class="mi">1</span>
    <span class="mi">2</span>
    <span class="mi">3</span>
</pre></div>


<h4 id="133">1.3.3 生成器的执行状态</h4>
<p>生成器在其生命周期中，会有如下四个状态</p>
<ol>
<li>GEN_CREATED   # 等待开始执行</li>
<li>GEN_RUNNING    # 解释器正在执行（只有在多线程应用中才能看到这个状态）</li>
<li>GEN_SUSPENDED  # 在yield表达式处暂停</li>
<li>GEN_CLOSED     # 执行结束</li>
</ol>
<h4 id="134">1.3.4  生成器的异常处理</h4>
<p>在生成器工作过程中，若生成器不满足生成元素的条件，就会/应该 抛出异常（StopIteration）。</p>
<p>通过列表生成式构建的生成器，其内部已经自动帮我们实现了抛出异常这一步。<br />
所以我们在自己定义一个生成器的时候，我们也应该在不满足生成元素条件的时候，抛出异常。</p>
<div class="hlcode"><pre><span class="n">def</span> <span class="n">mygen</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">:</span>
    <span class="n">now</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">now</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">:</span>
        <span class="n">yield</span> <span class="n">now</span>
        <span class="n">now</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">raise</span> <span class="n">StopIteration</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="err">&#39;</span><span class="n">__main__</span><span class="err">&#39;</span><span class="o">:</span>
    <span class="n">gen</span> <span class="o">=</span> <span class="n">mygen</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
    <span class="n">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
    <span class="n">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
</pre></div>


<h4 id="135-yield">1.3.5 从生成器过渡到协程：yield</h4>
<ol>
<li>生成器暂停</li>
<li>生成器发送</li>
</ol>
<p><strong>1+2 实现协程</strong></p>
<p>通过上面的介绍，我们知道生成器为我们引入了<strong>暂停函数</strong>执行（yield）的功能。当有了暂停的功能之后，人们就想能不能在生成器暂停的时候向其<strong>发送一点东西</strong>（其实上面也有提及：send(None)）。这种向暂停的生成器发送信息的功能通过 PEP 342 进入 Python 2.5 中，并催生了 Python 中协程的诞生。根据 wikipedia 中的定义</p>
<p>协程是为非抢占式多任务产生子程序的计算机程序组件，协程允许不同入口点在不同位置暂停或开始执行程序。</p>
<p>注意从本质上而言，<strong>协程并不属于语言中的概念，而是编程模型上的概念</strong>。<br />
协程和线程，有相似点，多个协程之间和线程一样，只会交叉串行执行；也有不同点，<strong>线程之间要频繁进行切换，加锁，解锁</strong>，从复杂度和效率来看，和协程相比，这确是一个痛点。协程通过使用 yield 暂停生成器，可以将程序的执行流程交给其他的子程序，从而实现不同子程序的之间的交替执行。<br />
下面通过一个简明的演示来看看，如何向生成器中发送消息。</p>
<div class="hlcode"><pre><span class="n">def</span> <span class="n">jumping_range</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">:</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">:</span>
        <span class="err">#</span> <span class="err">通过</span><span class="n">send</span><span class="p">()</span><span class="err">发送的信息将赋值给</span><span class="n">jump</span>
        <span class="n">jump</span> <span class="o">=</span> <span class="n">yield</span> <span class="n">index</span>
        <span class="k">if</span> <span class="n">jump</span> <span class="n">is</span> <span class="n">None</span><span class="o">:</span>
            <span class="n">jump</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">index</span> <span class="o">+=</span> <span class="n">jump</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="err">&#39;</span><span class="n">__main__</span><span class="err">&#39;</span><span class="o">:</span>
    <span class="n">itr</span> <span class="o">=</span> <span class="n">jumping_range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">print</span><span class="p">(</span><span class="n">next</span><span class="p">(</span><span class="n">itr</span><span class="p">))</span>
    <span class="n">print</span><span class="p">(</span><span class="n">itr</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">print</span><span class="p">(</span><span class="n">next</span><span class="p">(</span><span class="n">itr</span><span class="p">))</span>
    <span class="n">print</span><span class="p">(</span><span class="n">itr</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</pre></div>


<p>输出：</p>
<div class="hlcode"><pre>    <span class="mi">0</span>
    <span class="mi">2</span>
    <span class="mi">3</span>
    <span class="mi">2</span>
</pre></div>


<p>这里解释下为什么这么输出。重点是<code>jump = yield index</code>这个语句。<br />
分成两部分：</p>
<div class="hlcode"><pre><span class="n">yield</span> <span class="n">index</span> <span class="err">是将</span><span class="n">index</span> <span class="n">return</span><span class="err">给外部调用程序。</span>
<span class="n">jump</span> <span class="o">=</span> <span class="n">yield</span> <span class="err">可以接收外部程序通过</span><span class="n">send</span><span class="p">()</span><span class="err">发送的信息，并赋值给</span><span class="n">jump</span>
</pre></div>


<p>以上这些，都是讲协程并发的基础必备知识，请一定要亲自去实践并理解它，不然后面的内容，将会变得枯燥无味，晦涩难懂。</p>
<p>下一章，我将讲一个Python3.5新引入的语法：yield from。篇幅也比较多，所以就单独拿出来讲。</p>
<p>协程是在单线程里实现任务的切换的<br />
利用同步的方式去实现异步<br />
不再需要锁，提高了并发性能</p>
<h2 id="3-io-">3. 异步IO框架--协程</h2>
<p>单线程的异步编程模型称为协程（Coroutine），协程是一种程序组件，也称为微线程。</p>
<p>1 线程（Thread）=协程（Coroutine）+协程（Coroutine）+协程（Coroutine）</p>
<h3 id="yield">yield</h3>
<p>Python通过yield提供了对协程的基本支持</p>
<h3 id="gevent-">gevent --第三方库</h3>
<p>Python通过yield提供了对协程的基本支持，但是不完全。而第三方的gevent为Python提供了比较完善的协程支持。</p>
<p>gevent是第三方库，通过greenlet实现协程，其基本思想是：</p>
<p>当一个greenlet遇到IO操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO。</p>
<p>由于切换是在IO操作时自动完成，所以gevent需要修改Python自带的一些标准库，这一过程在启动时通过monkey patch完成：</p>
<div class="hlcode"><pre><span class="c"># bin/bash/python2.6</span>
<span class="kn">from</span> <span class="nn">gevent</span> <span class="kn">import</span> <span class="n">monkey</span><span class="p">;</span> <span class="n">monkey</span><span class="o">.</span><span class="n">patch_socket</span><span class="p">()</span>
<span class="kn">import</span> <span class="nn">gevent</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">print</span> <span class="n">gevent</span><span class="o">.</span><span class="n">getcurrent</span><span class="p">(),</span> <span class="n">i</span>

<span class="n">g1</span> <span class="o">=</span> <span class="n">gevent</span><span class="o">.</span><span class="n">spawn</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">g2</span> <span class="o">=</span> <span class="n">gevent</span><span class="o">.</span><span class="n">spawn</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">g3</span> <span class="o">=</span> <span class="n">gevent</span><span class="o">.</span><span class="n">spawn</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">g1</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
<span class="n">g2</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
<span class="n">g3</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

<span class="err">运行结果：</span>
<span class="o">&lt;</span><span class="n">Greenlet</span> <span class="n">at</span> <span class="mh">0x10e49f550</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">0</span>
<span class="o">&lt;</span><span class="n">Greenlet</span> <span class="n">at</span> <span class="mh">0x10e49f550</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">1</span>
<span class="o">&lt;</span><span class="n">Greenlet</span> <span class="n">at</span> <span class="mh">0x10e49f550</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">2</span>
<span class="o">&lt;</span><span class="n">Greenlet</span> <span class="n">at</span> <span class="mh">0x10e49f550</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">3</span>
<span class="o">&lt;</span><span class="n">Greenlet</span> <span class="n">at</span> <span class="mh">0x10e49f550</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">4</span>
<span class="o">&lt;</span><span class="n">Greenlet</span> <span class="n">at</span> <span class="mh">0x10e49f910</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">0</span>
<span class="o">&lt;</span><span class="n">Greenlet</span> <span class="n">at</span> <span class="mh">0x10e49f910</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">1</span>
<span class="o">&lt;</span><span class="n">Greenlet</span> <span class="n">at</span> <span class="mh">0x10e49f910</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">2</span>
<span class="o">&lt;</span><span class="n">Greenlet</span> <span class="n">at</span> <span class="mh">0x10e49f910</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">3</span>
<span class="o">&lt;</span><span class="n">Greenlet</span> <span class="n">at</span> <span class="mh">0x10e49f910</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">4</span>
<span class="o">&lt;</span><span class="n">Greenlet</span> <span class="n">at</span> <span class="mh">0x10e49f4b0</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">0</span>
<span class="o">&lt;</span><span class="n">Greenlet</span> <span class="n">at</span> <span class="mh">0x10e49f4b0</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">1</span>
<span class="o">&lt;</span><span class="n">Greenlet</span> <span class="n">at</span> <span class="mh">0x10e49f4b0</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">2</span>
<span class="o">&lt;</span><span class="n">Greenlet</span> <span class="n">at</span> <span class="mh">0x10e49f4b0</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">3</span>
<span class="o">&lt;</span><span class="n">Greenlet</span> <span class="n">at</span> <span class="mh">0x10e49f4b0</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">4</span>
<span class="err">可以看到，</span><span class="mi">3</span><span class="err">个</span><span class="n">greenlet</span><span class="err">是依次运行而不是交替运行。</span>
</pre></div>


<p>要让greenlet交替运行，可以通过gevent.sleep()交出控制权：</p>
<div class="hlcode"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">print</span> <span class="n">gevent</span><span class="o">.</span><span class="n">getcurrent</span><span class="p">(),</span> <span class="n">i</span>
        <span class="n">gevent</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="err">执行结果：</span>

<span class="o">&lt;</span><span class="n">Greenlet</span> <span class="n">at</span> <span class="mh">0x10cd58550</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">0</span>
<span class="o">&lt;</span><span class="n">Greenlet</span> <span class="n">at</span> <span class="mh">0x10cd58910</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">0</span>
<span class="o">&lt;</span><span class="n">Greenlet</span> <span class="n">at</span> <span class="mh">0x10cd584b0</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">0</span>
<span class="o">&lt;</span><span class="n">Greenlet</span> <span class="n">at</span> <span class="mh">0x10cd58550</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">1</span>
<span class="o">&lt;</span><span class="n">Greenlet</span> <span class="n">at</span> <span class="mh">0x10cd584b0</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">1</span>
<span class="o">&lt;</span><span class="n">Greenlet</span> <span class="n">at</span> <span class="mh">0x10cd58910</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">1</span>
<span class="o">&lt;</span><span class="n">Greenlet</span> <span class="n">at</span> <span class="mh">0x10cd58550</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">2</span>
<span class="o">&lt;</span><span class="n">Greenlet</span> <span class="n">at</span> <span class="mh">0x10cd58910</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">2</span>
<span class="o">&lt;</span><span class="n">Greenlet</span> <span class="n">at</span> <span class="mh">0x10cd584b0</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">2</span>
<span class="o">&lt;</span><span class="n">Greenlet</span> <span class="n">at</span> <span class="mh">0x10cd58550</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">3</span>
<span class="o">&lt;</span><span class="n">Greenlet</span> <span class="n">at</span> <span class="mh">0x10cd584b0</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">3</span>
<span class="o">&lt;</span><span class="n">Greenlet</span> <span class="n">at</span> <span class="mh">0x10cd58910</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">3</span>
<span class="o">&lt;</span><span class="n">Greenlet</span> <span class="n">at</span> <span class="mh">0x10cd58550</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">4</span>
<span class="o">&lt;</span><span class="n">Greenlet</span> <span class="n">at</span> <span class="mh">0x10cd58910</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">4</span>
<span class="o">&lt;</span><span class="n">Greenlet</span> <span class="n">at</span> <span class="mh">0x10cd584b0</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">4</span>
<span class="mi">3</span><span class="err">个</span><span class="n">greenlet</span><span class="err">交替运行，</span>
</pre></div>


<p>把循环次数改为500000，让它们的运行时间长一点，然后在操作系统的进程管理器中看，线程数只有1个。</p>
<p>当然，实际代码里，我们不会用gevent.sleep()去切换协程，而是在执行到IO操作时，gevent自动切换，代码如下：</p>
<div class="hlcode"><pre><span class="kn">from</span> <span class="nn">gevent</span> <span class="kn">import</span> <span class="n">monkey</span><span class="p">;</span> <span class="n">monkey</span><span class="o">.</span><span class="n">patch_all</span><span class="p">()</span>
<span class="kn">import</span> <span class="nn">gevent</span>
<span class="kn">import</span> <span class="nn">urllib2</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;GET: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">url</span><span class="p">)</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="n">urllib2</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">resp</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%d</span><span class="s"> bytes received from </span><span class="si">%s</span><span class="s">.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">url</span><span class="p">))</span>

<span class="n">gevent</span><span class="o">.</span><span class="n">joinall</span><span class="p">([</span>
        <span class="n">gevent</span><span class="o">.</span><span class="n">spawn</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">&#39;https://www.python.org/&#39;</span><span class="p">),</span>
        <span class="n">gevent</span><span class="o">.</span><span class="n">spawn</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">&#39;https://www.yahoo.com/&#39;</span><span class="p">),</span>
        <span class="n">gevent</span><span class="o">.</span><span class="n">spawn</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">&#39;https://github.com/&#39;</span><span class="p">),</span>
<span class="p">])</span>


<span class="o">&gt;&gt;&gt;</span><span class="err">运行结果：</span>
<span class="n">GET</span><span class="p">:</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">www</span><span class="o">.</span><span class="n">python</span><span class="o">.</span><span class="n">org</span><span class="o">/</span>
<span class="n">GET</span><span class="p">:</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">www</span><span class="o">.</span><span class="n">yahoo</span><span class="o">.</span><span class="n">com</span><span class="o">/</span>
<span class="n">GET</span><span class="p">:</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span>
<span class="mi">45661</span> <span class="nb">bytes</span> <span class="n">received</span> <span class="kn">from</span> <span class="nn">https</span><span class="p">:</span><span class="o">//</span><span class="n">www</span><span class="o">.</span><span class="n">python</span><span class="o">.</span><span class="n">org</span><span class="o">/.</span>
<span class="mi">14823</span> <span class="nb">bytes</span> <span class="n">received</span> <span class="kn">from</span> <span class="nn">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/.</span>
<span class="mi">304034</span> <span class="nb">bytes</span> <span class="n">received</span> <span class="kn">from</span> <span class="nn">https</span><span class="p">:</span><span class="o">//</span><span class="n">www</span><span class="o">.</span><span class="n">yahoo</span><span class="o">.</span><span class="n">com</span><span class="o">/.</span>
<span class="err">从结果看，</span><span class="mi">3</span><span class="err">个网络操作是并发执行的，而且结束顺序不同，但只有一个线程。</span>
</pre></div>


<h1 id="_2">示例</h1>
<h2 id="for">将for 循环使用多线程处理</h2>
<div class="hlcode"><pre><span class="n">results</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">item_list</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="k">return</span> <span class="n">results</span>



<span class="kn">from</span> <span class="nn">multiprocessing.dummy</span> <span class="kn">import</span> <span class="n">Pool</span> <span class="k">as</span> <span class="n">ThreadPool</span>
<span class="n">pool</span> <span class="o">=</span> <span class="n">ThreadPool</span><span class="p">()</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">item_list</span><span class="p">)</span>
<span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</pre></div>


<h1 id="_3">进程池</h1>
<p>ProcessPoolExecutor</p>
<h1 id="_4">线程池的基本使用</h1>
<p>从Python3.2开始，标准库为我们提供了 concurrent.futures 模块，它提供了 <code>ThreadPoolExecutor</code> (线程池)。</p>
<h2 id="submit">submit</h2>
<p>相比 threading 等模块，该模块通过 submit 返回的是一个 future 对象，它是一个未来可期的对象，通过它可以获悉线程的状态主线程(或进程)中可以获取某一个线程(进程)执行的状态或者某一个任务执行的状态及返回值：</p>
<p>主线程可以获取某一个线程（或者任务的）的状态，以及返回值。当一个线程完成的时候，主线程能够立即知道。<br />
让多线程和多进程的编码接口一致。</p>
<div class="hlcode"><pre><span class="c"># coding: utf-8</span>
<span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ThreadPoolExecutor</span>
<span class="kn">import</span> <span class="nn">time</span>


<span class="k">def</span> <span class="nf">spider</span><span class="p">(</span><span class="n">page</span><span class="p">):</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">page</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">&quot;crawl task{page} finished&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">page</span>

<span class="k">with</span> <span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span> <span class="k">as</span> <span class="n">t</span><span class="p">:</span>  <span class="c"># 创建一个最大容纳数量为5的线程池</span>
    <span class="n">task1</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">spider</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">task2</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">spider</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c"># 通过submit提交执行的函数到线程池中</span>
    <span class="n">task3</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">spider</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">&quot;task1: {task1.done()}&quot;</span><span class="p">)</span>  <span class="c"># 通过done来判断线程是否完成</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">&quot;task2: {task2.done()}&quot;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">&quot;task3: {task3.done()}&quot;</span><span class="p">)</span>

    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">2.5</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">&quot;task1: {task1.done()}&quot;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">&quot;task2: {task2.done()}&quot;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">&quot;task3: {task3.done()}&quot;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">task1</span><span class="o">.</span><span class="n">result</span><span class="p">())</span>  <span class="c"># 通过result来获取返回值</span>
<span class="o">&gt;&gt;&gt;</span>

<span class="n">task1</span><span class="p">:</span> <span class="bp">False</span>
<span class="n">task2</span><span class="p">:</span> <span class="bp">False</span>
<span class="n">task3</span><span class="p">:</span> <span class="bp">False</span>
<span class="n">crawl</span> <span class="n">task1</span> <span class="n">finished</span>
<span class="n">crawl</span> <span class="n">task2</span> <span class="n">finished</span>
<span class="n">task1</span><span class="p">:</span> <span class="bp">True</span>
<span class="n">task2</span><span class="p">:</span> <span class="bp">True</span>
<span class="n">task3</span><span class="p">:</span> <span class="bp">False</span>
<span class="n">crawl</span> <span class="n">task3</span> <span class="n">finished</span>
</pre></div>


<p>使用 with 语句 ，通过 ThreadPoolExecutor 构造实例，同时传入 max_workers 参数来设置线程池中最多能同时运行的线程数目。</p>
<p>使用 submit 函数来提交线程需要执行的任务到线程池中，并返回该任务的句柄（类似于文件、画图），注意 submit() 不是阻塞的，而是立即返回。</p>
<p>通过使用 done() 方法判断该任务是否结束。上面的例子可以看出，提交任务后立即判断任务状态，显示四个任务都未完成。在延时2.5后，task1 和 task2 执行完毕，task3 仍在执行中。</p>
<p>使用 result() 方法可以获取任务的返回值。</p>
<h2 id="wait">wait</h2>
<div class="hlcode"><pre><span class="n">wait</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">return_when</span><span class="o">=</span><span class="n">ALL_COMPLETED</span><span class="p">)</span>
</pre></div>


<p>wait 接受三个参数：<br />
fs: 表示需要执行的序列<br />
timeout: 等待的最大时间，如果超过这个时间即使线程未执行完成也将返回<br />
return_when：表示wait返回结果的条件，默认为 ALL_COMPLETED 全部执行完成再返回</p>
<p>还是用上面那个例子来熟悉用法<br />
示例：</p>
<div class="hlcode"><pre><span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ThreadPoolExecutor</span><span class="p">,</span> <span class="n">wait</span><span class="p">,</span> <span class="n">FIRST_COMPLETED</span><span class="p">,</span> <span class="n">ALL_COMPLETED</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">spider</span><span class="p">(</span><span class="n">page</span><span class="p">):</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">page</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">&quot;crawl task{page} finished&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">page</span>

<span class="k">with</span> <span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span> <span class="k">as</span> <span class="n">t</span><span class="p">:</span> 
    <span class="n">all_task</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">spider</span><span class="p">,</span> <span class="n">page</span><span class="p">)</span> <span class="k">for</span> <span class="n">page</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)]</span>
    <span class="n">wait</span><span class="p">(</span><span class="n">all_task</span><span class="p">,</span> <span class="n">return_when</span><span class="o">=</span><span class="n">FIRST_COMPLETED</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;finished&#39;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">wait</span><span class="p">(</span><span class="n">all_task</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mf">2.5</span><span class="p">))</span>

<span class="c"># 运行结果</span>
<span class="n">crawl</span> <span class="n">task1</span> <span class="n">finished</span>
<span class="n">finished</span>
<span class="n">crawl</span> <span class="n">task2</span> <span class="n">finished</span>
<span class="n">crawl</span> <span class="n">task3</span> <span class="n">finished</span>
<span class="n">DoneAndNotDoneFutures</span><span class="p">(</span><span class="n">done</span><span class="o">=</span><span class="p">{</span><span class="o">&lt;</span><span class="n">Future</span> <span class="n">at</span> <span class="mh">0x28c8710</span> <span class="n">state</span><span class="o">=</span><span class="n">finished</span> <span class="n">returned</span> <span class="nb">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">Future</span> <span class="n">at</span> <span class="mh">0x2c2bfd0</span> <span class="n">state</span><span class="o">=</span><span class="n">finished</span> <span class="n">returned</span> <span class="nb">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">Future</span> <span class="n">at</span> <span class="mh">0x2c1b7f0</span> <span class="n">state</span><span class="o">=</span><span class="n">finished</span> <span class="n">returned</span> <span class="nb">int</span><span class="o">&gt;</span><span class="p">},</span> <span class="n">not_done</span><span class="o">=</span><span class="p">{</span><span class="o">&lt;</span><span class="n">Future</span> <span class="n">at</span> <span class="mh">0x2c3a240</span> <span class="n">state</span><span class="o">=</span><span class="n">running</span><span class="o">&gt;</span><span class="p">})</span>
<span class="n">crawl</span> <span class="n">task4</span> <span class="n">finished</span>
</pre></div>


<p>代码中返回的条件是：当完成第一个任务的时候，就停止等待，继续主线程任务<br />
由于设置了延时， 可以看到最后只有 task4 还在运行中</p>
<h2 id="as_completed">as_completed</h2>
<p>上面虽然提供了判断任务是否结束的方法，但是不能在主线程中一直判断啊。最好的方法是当某个任务结束了，就给主线程返回结果，而不是一直判断每个任务是否结束。</p>
<p>ThreadPoolExecutorThreadPoolExecutor 中 的 as_completed() 就是这样一个方法，当子线程中的任务执行完后，直接用 result() 获取返回结果</p>
<p>用法如下：</p>
<div class="hlcode"><pre><span class="c"># coding: utf-8</span>
<span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ThreadPoolExecutor</span><span class="p">,</span> <span class="n">as_completed</span>
<span class="kn">import</span> <span class="nn">time</span>


<span class="k">def</span> <span class="nf">spider</span><span class="p">(</span><span class="n">page</span><span class="p">):</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">page</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">&quot;crawl task{page} finished&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">page</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">with</span> <span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span> <span class="k">as</span> <span class="n">t</span><span class="p">:</span>
        <span class="n">obj_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">page</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">spider</span><span class="p">,</span> <span class="n">page</span><span class="p">)</span>
            <span class="n">obj_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">future</span> <span class="ow">in</span> <span class="n">as_completed</span><span class="p">(</span><span class="n">obj_list</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
            <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">&quot;main: {data}&quot;</span><span class="p">)</span>

<span class="c"># 执行结果</span>
<span class="n">crawl</span> <span class="n">task1</span> <span class="n">finished</span>
<span class="n">main</span><span class="p">:</span> <span class="mi">1</span>
<span class="n">crawl</span> <span class="n">task2</span> <span class="n">finished</span>
<span class="n">main</span><span class="p">:</span> <span class="mi">2</span>
<span class="n">crawl</span> <span class="n">task3</span> <span class="n">finished</span>
<span class="n">main</span><span class="p">:</span> <span class="mi">3</span>
<span class="n">crawl</span> <span class="n">task4</span> <span class="n">finished</span>
<span class="n">main</span><span class="p">:</span> <span class="mi">4</span>
<span class="n">as_completed</span><span class="p">()</span> 
</pre></div>


<p>方法是一个生成器，在没有任务完成的时候，会一直阻塞，除非设置了 timeout。</p>
<p>当有某个任务完成的时候，会 yield 这个任务，就能执行 for 循环下面的语句，然后继续阻塞住，循环到所有的任务结束。同时，先完成的任务会先返回给主线程。</p>
<h2 id="map">map</h2>
<p>map(fn, *iterables, timeout=None)<br />
fn： 第一个参数 fn 是需要线程执行的函数；<br />
iterables：第二个参数接受一个可迭代对象；<br />
timeout： 第三个参数 timeout 跟 wait() 的 timeout 一样，但由于 map 是返回线程执行的结果，如果 timeout小于线程执行时间会抛异常 TimeoutError。</p>
<p>用法如下:</p>
<div class="hlcode"><pre><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ThreadPoolExecutor</span>

<span class="k">def</span> <span class="nf">spider</span><span class="p">(</span><span class="n">page</span><span class="p">):</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">page</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">page</span>

<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">executor</span> <span class="o">=</span> <span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

<span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">executor</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">spider</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;task{}:{}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">result</span><span class="p">))</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="c">#  运行结果</span>
<span class="n">task1</span><span class="p">:</span><span class="mi">2</span>
<span class="n">task2</span><span class="p">:</span><span class="mi">3</span>
<span class="n">task3</span><span class="p">:</span><span class="mi">1</span>
<span class="n">task4</span><span class="p">:</span><span class="mi">4</span>
</pre></div>


<p>使用 map 方法，无需提前使用 submit 方法，map 方法与 python 高阶函数 map 的含义相同，都是将序列中的每个元素都执行同一个函数。</p>
<p>上面的代码对列表中的每个元素都执行 spider() 函数，并分配各线程池。</p>
<p>可以看到执行结果与上面的 as_completed() 方法的结果不同，输出顺序和列表的顺序相同，就算 1s 的任务先执行完成，也会先打印前面提交的任务返回的结果。</p>
</div>
<div id="renote">
  <HR style=" FILTER: alpha (opacity = 100, finishopacity =0 , style= 3 )" width="80%" color=#987 cb 9 SIZE=3>
  <p>如果你觉得这篇文章对你有帮助，不妨请我喝杯咖啡，鼓励我创造更多!</p>
  <img src="/Wiki/static/images/pay.jpg" width="25%">
</div>

    </div>
    <div id="footer">
        <span>
            Copyright © 2021 zhang787jun.
            Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.
        </span>
    </div>

    
</body>
<script>
    function changeImgurl(site_root_url) {
        var images = document.images;
        var site_root = site_root_url;
        for (i = 0, len = images.length; i < len; i++) {
            image = images[i];
            image_src = image.src;
            if (image_src.search("attach") >= 0) {
                re_image_src = image_src.slice(image_src.search("attach"));
                abs_image_src = (site_root.endsWith("/")) ? site_root + re_image_src : site_root + "/" +
                    re_image_src;
                image.src = abs_image_src;
            }
        }
    }
    var site_root_url = "/Wiki";
    changeImgurl(site_root_url);
    let isMathjaxConfig = false; // 防止重复调用Config，造成性能损耗
    const initMathjaxConfig = () => {
        if (!window.MathJax) {
            return;
        }
        window.MathJax.Hub.Config({
            showProcessingMessages: false, //关闭js加载过程信息
            messageStyle: "none", //不显示信息
            jax: ["input/TeX", "output/HTML-CSS"],
            tex2jax: {
                inlineMath: [["$", "$"], ["\\(", "\\)"]], //行内公式选择符
                displayMath: [["$$", "$$"], ["\\[", "\\]"]], //段内公式选择符
                skipTags: ["script", "noscript", "style", "textarea", "pre", "code", "a"] //避开某些标签
            },
            "HTML-CSS": {
                availableFonts: ["STIX", "TeX"], //可选字体
                showMathMenu: false //关闭右击菜单显示
            }
        });
        isMathjaxConfig = true; //
    };
    if (isMathjaxConfig === false) {
        // 如果：没有配置MathJax
        initMathjaxConfig();
    };
</script>

</html>