<!DOCTYPE HTML>
<html>

<head>
    <link rel="Stylesheet" type="text/css" href="/Wiki/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/Wiki/static/css/tango.css">
    <link rel="shortcut icon" href="/Wiki/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/Wiki/favicon.ico" type="image/x-icon">
    <title>00-分布式系统基础 - Jun's personal knowledge wiki</title>
    <meta name="keywords" content="Technology, MachineLearning, DataMining, Wiki" />
    <meta name="description" content="A wiki website" />
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
</head>

<body>
    <div id="container">
        
<div id="header">
  <div id="post-nav"><a href="/Wiki/">Home</a>&nbsp;»&nbsp;<a href="/Wiki/#分布式系统">分布式系统</a>&nbsp;»&nbsp;00-分布式系统基础</div>
</div>
<div class="clearfix"></div>
<div id="title">00-分布式系统基础</div>
<div id="content">
  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#1">1. 分布式系统</a><ul>
<li><a href="#11-6">1.1. 核心6问</a></li>
<li><a href="#12">1.2. 基本概念</a><ul>
<li><a href="#121">1.2.1. 什么是分布式系统</a></li>
<li><a href="#122">1.2.2. 副本</a></li>
<li><a href="#123">1.2.3. 副本控制协议</a></li>
<li><a href="#124-cap">1.2.4. CAP 理论</a><ul>
<li><a href="#1241-consistency">1.2.4.1. Consistency (一致性)：</a></li>
<li><a href="#1242-availiablity">1.2.4.2. Availiablity(可用性)：</a></li>
<li><a href="#1243-partition-tolerance">1.2.4.3. Partition tolerance（分区容错）：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#13">1.3. 分布式系统分类</a><ul>
<li><a href="#131-dos">1.3.1. 分布式操作系统 DOS</a></li>
<li><a href="#132-nos">1.3.2. 分布式网络系统 NOS</a></li>
<li><a href="#133-nos">1.3.3. 分布式中间件 NOS</a></li>
</ul>
</li>
<li><a href="#14">1.4. 分布式系统架构</a><ul>
<li><a href="#141">1.4.1. 中心化系统架构</a></li>
<li><a href="#142">1.4.2. 去中心化系统架构</a></li>
</ul>
</li>
<li><a href="#15-">1.5. 分布式系统--容错技术</a></li>
<li><a href="#16-">1.6. 分布式系统--通信技术</a><ul>
<li><a href="#161">1.6.1. 同一节点内</a></li>
<li><a href="#162">1.6.2. 不同节点内</a></li>
</ul>
</li>
<li><a href="#17-">1.7. 分布式系统--进程线程管理</a></li>
<li><a href="#18-">1.8. 分布式系统--同步机制</a><ul>
<li><a href="#181">1.8.1. 资源分为：</a></li>
<li><a href="#182">1.8.2. 同步机制的评价</a></li>
<li><a href="#183">1.8.3. 互斥问题</a></li>
</ul>
</li>
<li><a href="#19-">1.9. 分布式系统--独一性命名</a></li>
</ul>
</li>
</ul>
</div>
<h1 id="1">1. 分布式系统</h1>
<h2 id="11-6">1.1. 核心6问</h2>
<p>团队愿景（集群是用来干嘛的）<br />
团队结构（集群由哪些节点组成）<br />
团队沟通（节点之间怎么通信）<br />
团队运作（一个工作job分配下来是怎样运作的）<br />
公共资源分配（共享资源如何处理）<br />
队员冲突处理（容错机制）</p>
<h2 id="12">1.2. 基本概念</h2>
<h3 id="121">1.2.1. 什么是分布式系统</h3>
<p>分布式系统（distributed system）：以一定结构规则可以相互连接的好多节点（服务器）</p>
<h3 id="122">1.2.2. 副本</h3>
<p>副本（replica/copy）：指在分布式系统中为<strong>数据</strong>或<strong>服务</strong>提供的冗余。</p>
<ol>
<li>
<p>数据副本 <br />
   指在不同的节点上持久化同一份数据，当出现某一个节点的存储的数据丢失时，可以从副本上读到数据。数据副本是分布式系统解决数据丢失异常的唯一手段。<br />
   如 备份的数据库，GFS里面的chuck 都是数据副本</p>
</li>
<li>
<p>服务副本<br />
   指数个节点提供某种相同的服务，这种服务一般并不依赖于节点的本地存储，其所需数据一般来自其他节点。  MapReduce里面 WorkNode， 分布式Tensorflow 里的多个Work node /device 都是服务副本</p>
</li>
</ol>
<h3 id="123">1.2.3. 副本控制协议</h3>
<p>副本控制协议：指按特定的协议流程控制副本数据的读写行为，使得副本满足一定的可用性和一致性要求的分布式协议。</p>
<p>例如：<br />
1. 中心化副本协议<br />
   primary-secondary协议<br />
2. 去中心化副本协议<br />
   paxos</p>
<h3 id="124-cap">1.2.4. CAP 理论</h3>
<p><img alt="CAP 理论" src="/attach/images/2019-08-06-13-46-18.png" /></p>
<p>CAP 理论是由 加州大学的计算机科学家Eric Brewer 提出的分布式系统中最为重要的理论之一。</p>
<p>CAP 理论的定义很简单，CAP 三个字母分别代表了分布式系统中三个相互矛盾的属性</p>
<h4 id="1241-consistency">1.2.4.1. Consistency (一致性)：</h4>
<p>Consistency (一致性)：CAP 理论中的副本一致性特指强一致性；指的是各个节点的数据一致</p>
<h4 id="1242-availiablity">1.2.4.2. Availiablity(可用性)：</h4>
<p>指系统在出现异常时已经可以提供服务 </p>
<h4 id="1243-partition-tolerance">1.2.4.3. Partition tolerance（分区容错）：</h4>
<p>大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错的意思是，某一个或多个区间的通信可能失败。<br />
比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。<strong>分区容错要允许系统存在这样的错误</strong></p>
<p>分区容错无法避免，因此可以认为 CAP 的 P 总是成立。CAP 定理告诉我们，剩下的 C 和 A 无法同时做到。</p>
<p>读者问，在什么场合，可用性高于一致性？</p>
<p>举例来说，发布一张网页到 CDN，多个服务器有这张网页的副本。后来发现一个错误，需要更新网页，这时只能每个服务器都更新一遍。</p>
<p>一般来说，网页的更新不是特别强调一致性。短时期内，一些用户拿到老版本，另一些用户拿到新版本，问题不会特别大。当然，所有人最终都会看到新版本。所以，这个场合就是可用性高于一致性。</p>
<h2 id="13">1.3. 分布式系统分类</h2>
<h3 id="131-dos">1.3.1. 分布式操作系统 DOS</h3>
<h3 id="132-nos">1.3.2. 分布式网络系统 NOS</h3>
<h3 id="133-nos">1.3.3. 分布式中间件 NOS</h3>
<p>分布式中间件没有一个比较清晰的定义，一般指位于平台（OS+硬件）与应用之间的通用服务。<br />
基于目的和实现机制的不同，将平台分为以下几类</p>
<ol>
<li>远程过程调用（rpc）</li>
<li>面向消息的中间件（Message-Oriented Middleware）</li>
<li>事务处理监控（transaction process monitors）<br />
事务管理与协调，负载平衡、失败恢复</li>
</ol>
<h2 id="14">1.4. 分布式系统架构</h2>
<p>副本控制协议主要分为两大类：“中心化(centralized)副本控制协议”和“去中心化(decentralized)副本控制协议”。</p>
<p>所以 分布式系统架构主要有"中心化"和“去中心化”两类</p>
<h3 id="141">1.4.1. 中心化系统架构</h3>
<p>• 中心化：中心化的设计思想在自然界和人类生活中是如此的普遍和自然，它的设计思想也很简单，分布式集群中的节点按照角色分工，可以分为两种角色--“领导”和“干活的”，中心化的一个思路就是“领导”通常分发任务并监督“干活的”，谁空闲了就给它安排任务，谁病倒了就一脚踢出去，然后把它的任务分给其他人；中心化的另一个思路是领导只负责生成任务而不再指派任务，由每个“干活的”自发去领任务。</p>
<h3 id="142">1.4.2. 去中心化系统架构</h3>
<p>• 去中心化：全球IP互联网就是一个典型的去中心化的分布式控制架构，联网的任意设备宕机都只会影响很小范围的功能。去中心化设计通常没有“领导”和“干活的”，角色一样，地位平等，因此不存在单点故障。实际上，完全意义的去中心化分布式系统并不多见，很多看起来是去中心化但工作机制采用了中心化设计思想的分布式系统正在不断涌现，在这种架构下，集群中的领导是动态选择出来的，而不是人为预先指定的，而且在集群发生故障的情况下，集群的成员会自发举行会议选举新的领导。典型案例如：zookeeper、以及Go语言实现的Etcd。</p>
<p>在这种架构下，集群中的领导是动态选择出来的，而不是人为预先指定的，而且在集群发生故障的情况下，集群的成员会自发举行会议选举新的领导。典型案例如：zookeeper、以及Go语言实现的Etcd。</p>
<h2 id="15-">1.5. 分布式系统--容错技术</h2>
<p>错误的类型<br />
    1. 暂时性错误<br />
    2. 间歇性<br />
    3. 永久性</p>
<p>预防错误的冗余设置<br />
    1. 硬件冗余<br />
    2. 软件冗余<br />
    3. 信息冗余<br />
    4. 时间冗余</p>
<p>故障的基本处理方案：<br />
    1. 主动复制 将所有的复制模块协同进行，<br />
    2. 被动复制 只有一个模块处于被动状态，其他模块的交互状态由这一模块的检查点定期检查<br />
    3. 半主动复制</p>
<p>被动复制中的节点故障处理</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>类型</th>
<th></th>
<th>适用性</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>向后式恢复</td>
<td>恢复到上一个正常状态的checkpoint 检查点</td>
<td>适用于 系统故障无法预知和去掉的情况</td>
</tr>
<tr>
<td>2</td>
<td>向前式恢复</td>
<td>假定故障是已知的 或可以获得的，   将这些故障去掉，继续运行</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="16-">1.6. 分布式系统--通信技术</h2>
<h3 id="161">1.6.1. 同一节点内</h3>
<p>Unix 提供了信号、管道、命名管道、消息列队、共享内存等通讯机制</p>
<h3 id="162">1.6.2. 不同节点内</h3>
<p>提供了网络套接字等<br />
    1. socket通信<br />
    2. PVM/MPI通信<br />
    3. 中间件模式的通信<br />
        a. rpc<br />
基于web服务的通信</p>
<h2 id="17-">1.7. 分布式系统--进程线程管理</h2>
<h2 id="18-">1.8. 分布式系统--同步机制</h2>
<h3 id="181">1.8.1. 资源分为：</h3>
<div class="hlcode"><pre><span class="mf">1.</span> <span class="err">各进程可以同时访问</span>
<span class="mf">2.</span> <span class="err">不允许多个进程访问的</span><span class="o">--&gt;</span><span class="err">需要同步机制进行控制管理</span>
</pre></div>


<h3 id="182">1.8.2. 同步机制的评价</h3>
<div class="hlcode"><pre><span class="mf">1.</span> <span class="err">响应时间和吞吐量</span>
<span class="mf">2.</span> <span class="err">恢复能力</span>
<span class="mf">3.</span> <span class="err">开销</span>
<span class="mf">4.</span> <span class="err">公平性</span>
<span class="mf">5.</span> <span class="err">可拓展性</span>
<span class="mf">6.</span> <span class="err">连接方式</span>
<span class="mf">7.</span> <span class="err">初始化</span>
<span class="mf">8.</span> <span class="err">排序方法</span>
</pre></div>


<h3 id="183">1.8.3. 互斥问题</h3>
<p>互斥问题 ：定义一些基本的操作来解决共享资源的多个并发过程的冲突问题<br />
主要目标：保证在任意时刻，只有一个进程对限制性资源的访问<br />
互斥算法需要满足的三个条件：<br />
    1 . 依据获得资源进程必须先释放后，另一个进程才能获得<br />
    2. 不同请求应该该相应顺序得到满足。该顺序规则应该，提前规定，如安装逻辑时钟的要求<br />
    3. 若获得资源的每个进程都最终释放资源，则每个请求最终得到满足</p>
<h2 id="19-">1.9. 分布式系统--独一性命名</h2>
<p>大规模分布式并行处理系统是由许多松耦合的处理单元组成的，要注意的是，这里指的是处理单元而非处理器。每个单元内的CPU都有自己私有的资源，如总线、内存、硬盘等。这种结构最大的特点在于不共享资源。在不共享资源（Share Nothing）的分布式架构下，节点可以实现无限扩展，即计算能力和存储的扩展性可以成倍增长。</p>
<p>分布式 操作系统</p>
<table>
<thead>
<tr>
<th>System</th>
<th>Description</th>
<th>Main Goal</th>
</tr>
</thead>
<tbody>
<tr>
<td>DOS</td>
<td>Tightly-coupled operating system for multiprocessors and homogeneous multicomputers</td>
<td>Hide and manage hardware resources  隐藏和管理硬件资源</td>
</tr>
<tr>
<td>高度耦合操作系统</td>
<td></td>
<td></td>
</tr>
<tr>
<td>NOS</td>
<td>Loosely-coupled operating system for heterogeneous multicomputers (LAN and WAN)</td>
<td>Offer local services to remote clients</td>
</tr>
<tr>
<td>网络操作系统</td>
<td></td>
<td>将当地服务发布到远程</td>
</tr>
<tr>
<td>Middleware</td>
<td>位于平台（OS+硬件）与应用之间的通用服务</td>
<td>·Provide distribution transparenc提供分布式传输</td>
</tr>
</tbody>
</table>
</div>
<div id="renote">
  如果你觉得这篇文章对你有帮助，不妨请我喝杯咖啡，鼓励我创造更多
</div>

    </div>
    <div id="footer">
        <span>
            Copyright © 2019 zhang787jun.
            Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.
        </span>
    </div>
    
</body>
<script>
    function changeImgurl(site_root_url) {
        var images = document.images;
        var site_root = site_root_url;
        for (i = 0, len = images.length; i < len; i++) {
            image = images[i];
            image_src = image.src;
            if (image_src.search("attach") >= 0) {
                re_image_src = image_src.slice(image_src.search("attach"));
                abs_image_src = (site_root.endsWith("/")) ? site_root + re_image_src : site_root + "/" +
                    re_image_src;
                image.src = abs_image_src;
            }
        }
    }
    var site_root_url = "/Wiki";
    changeImgurl(site_root_url);
</script>

</html>